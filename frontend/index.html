<!doctype html>
<html lang="en">
  <head>

     <!--Character encoding-->
    <meta charset="utf-8" />
     <!--Display on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flare Distance Calculator</title>
    <!--root = top level element-->
    <!--controls background, text color, button color, etc-->
    <style>
      
      :root {
        --bg-1: #f3efe8;
        --bg-2: #e6eff5;
        --ink: #1b1d21;
        --muted: #5c6670;
        --accent: #d64a3a;
        --panel: #fffaf3;
        --line: #e3d9cd;
      }
      /* *--> universal selector/ apply this rule to every element */
      * {
        box-sizing: border-box;
      }
      /* *--> remove default margin to remove unwanted whitespace, sets default color, default font, and then 
      layered background to make light glow in certain areas*/
      /*Sets how the page is filled, body turns into CSS grid container and horizantally and vertically centers content
      padding adds space between edge of screen and content
      */
      body {
        margin: 0;
        color: var(--ink);
        font-family: "Avenir Next", "Avenir", "Gill Sans", "Calibri", "Trebuchet MS", sans-serif;
        background:
          radial-gradient(800px 500px at 10% 0%, #f9f2e9 0%, rgba(249, 242, 233, 0) 70%),
          radial-gradient(700px 600px at 90% 20%, #e6f1f8 0%, rgba(230, 241, 248, 0) 65%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 32px 16px 48px;
      }
      /*.shell is a centered content container that 
      keeps the page from getting too wide and spaces its children nicely.*/
      .shell {
        width: min(980px, 100%);
        display: grid;
        gap: 24px;
      }
      /*
      These rules style the header’s title and 
      subtitle to be bold, readable, and responsive across screen sizes.
      */
      header h1 {
        margin: 0 0 8px;
        letter-spacing: 0.02em;
        font-weight: 700;
        font-size: clamp(28px, 3.2vw, 40px);
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 16px;
      }
      /*card that wraps around the form and result area*/
      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 22px;
        box-shadow: 0 24px 60px rgba(27, 29, 33, 0.08);
        animation: rise 520ms ease-out;
      }
      /*stack panels with spacing*/

      /*selects panel if it comes after another panel and addes spaces between panels
      using adjacent sibling selector "+"*/
      .panel + .panel {
        margin-top: 18px;
      }

      /*Creates a large, framed area for showing visual*/
      .track-frame {
        width: 100%;
        height: 360px;
        border-radius: 16px;
        border: 1px solid var(--line);
        background: #fffdf8;
      }

      /*Styles secondary info text related to the track.*/
      .track-meta {
        margin-top: 12px;
        color: var(--muted);
        font-size: 14px;
      }
      /*A responsive grid that arranges form fields neatly across the page.
      Layout automatically adjusts to different screen sizes*/
      .grid {
        display: grid;
        gap: 14px;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      /*label styling*/
      label {
        display: grid;
        gap: 6px;
        font-size: 13px;
        color: var(--muted);
        letter-spacing: 0.02em;
      }
      /*input field styling*/
      input {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 15px;
        background: #ffffff;
        color: var(--ink);
      }
      /*things that happen when clicking into an input field*/
      input:focus {
        outline: 2px solid rgba(214, 74, 58, 0.35);
        border-color: var(--accent);
      }

      /*container for buttons and action control*/
      .actions {
        margin-top: 18px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      /*primary action button*/
      button {
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 999px;
        padding: 12px 20px;
        font-weight: 600;
        letter-spacing: 0.03em;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      /*hovering over a button*/
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(214, 74, 58, 0.3);
      }
      /*main text result*/
      .result {
        font-size: 18px;
        font-weight: 600;
      }
      /*secondary text*/
      .status {
        color: var(--muted);
        font-size: 14px;
      }
      /*highlight key value from result*/
      .result strong {
        color: var(--accent);
        font-size: 22px;
      }
      /*CSS animation (rise)
      keyframe - describes how an element should change over time during an animation*/
      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <h1>Flare Distance Calculator</h1>
        <p>Enter your simulation values and fetch the predicted distance.</p>
      </header>

      <section class="panel">
        <form id="distance-form">
          <div class="grid">
            <label>
              v (m/s)
              <input type="number" step="0.1" name="v" value="20" />
            </label>
            <label>
              batteryWh
              <input type="number" step="1" name="batteryWh" value="5000" />
            </label>
            <label>
              solarWhPerMin
              <input type="number" step="0.1" name="solarWhPerMin" value="5" />
            </label>
            <label>
              etaDrive
              <input type="number" step="0.01" name="etaDrive" value="0.9" />
            </label>
            <label>
              raceDayMin
              <input type="number" step="1" name="raceDayMin" value="480" />
            </label>
            <label>
              rWheel (m)
              <input type="number" step="0.0001" name="rWheel" value="0.2792" />
            </label>
            <label>
              tMax (N·m)
              <input type="number" step="0.1" name="tMax" value="45" />
            </label>
            <label>
              pMax (W)
              <input type="number" step="1" name="pMax" value="10000" />
            </label>
            <label>
              m (kg)
              <input type="number" step="0.1" name="m" value="285" />
            </label>
            <label>
              g (m/s^2)
              <input type="number" step="0.01" name="g" value="9.81" />
            </label>
            <label>
              cRr
              <input type="number" step="0.0001" name="cRr" value="0.0015" />
            </label>
            <label>
              rho
              <input type="number" step="0.001" name="rho" value="1.225" />
            </label>
            <label>
              cD
              <input type="number" step="0.01" name="cD" value="0.21" />
            </label>
            <label>
              a (m^2)
              <input type="number" step="0.001" name="a" value="0.456" />
            </label>
            <label>
              theta (rad)
              <input type="number" step="0.001" name="theta" value="0" />
            </label>
          </div>
          <div class="actions">
            <button type="submit">Compute Distance</button>
            <div class="result" id="result">Distance: <strong>--</strong> m</div>
            <div class="status" id="status"></div>
          </div>
        </form>
      </section>
      <!--panels are just styled containers-->
      <section class="panel">
        <h2>Track Preview</h2>
        <!--SVG = Scalable Vector Graphing to draw track-->
        <svg class="track-frame" viewBox="0 0 600 360" role="img" aria-label="Track visualization">
          <path id="track-path" d="" fill="none" stroke="#d64a3a" stroke-width="6" stroke-linecap="round" />
        </svg>
        <div class="track-meta" id="track-status">Loading track...</div>
      </section>
    </div>

    <script>
      const form = document.getElementById("distance-form");
      const result = document.getElementById("result");
      const status = document.getElementById("status");
      const trackPath = document.getElementById("track-path");
      const trackStatus = document.getElementById("track-status");
      const trackSvg = document.querySelector(".track-frame");

      const fields = [
        "v",
        "batteryWh",
        "solarWhPerMin",
        "etaDrive",
        "raceDayMin",
        "rWheel",
        "tMax",
        "pMax",
        "m",
        "g",
        "cRr",
        "rho",
        "cD",
        "a",
        "theta",
      ];
      //converting user input to num
      function toNumber(value) {
        const num = Number.parseFloat(value);
        return Number.isFinite(num) ? num : null;
      }

      
      function renderTrack(segments) {
        //location
        let x = 0;
        let y = 0;
        let heading = 0; //direction facing
        const points = [{ x, y }]; //store points that have been visited
        let d = `M ${x} ${y}`; //path string that is being built. M = move to (in SVG)

        for (const seg of segments) {
          if (seg.type === "straight") {
            const length = seg.length || 0;
            x += length * Math.cos(heading);
            y += length * Math.sin(heading);
            d += ` L ${x} ${y}`; //draw line to new point
            points.push({ x, y });
            continue;
          }

          if (seg.type === "curve") {
            const radius = seg.radius || 0;
            const angleDeg = seg.angle || 0;
            if (radius <= 0 || angleDeg === 0) {
              continue;
            }
            //finds center of circle then rotates around the center to find the endpoint of arc
            const isRight = (seg.direction || "").toLowerCase() === "right";
            const delta = (Math.PI / 180) * (isRight ? angleDeg : -angleDeg);
            const normalX = isRight ? -Math.sin(heading) : Math.sin(heading);
            const normalY = isRight ? Math.cos(heading) : -Math.cos(heading);
            const centerX = x + radius * normalX;
            const centerY = y + radius * normalY;
            const dx = x - centerX;
            const dy = y - centerY;
            const cos = Math.cos(delta);
            const sin = Math.sin(delta);
            const endX = centerX + dx * cos - dy * sin;
            const endY = centerY + dx * sin + dy * cos;
            const largeArc = Math.abs(angleDeg) > 180 ? 1 : 0;
            const sweep = isRight ? 1 : 0;

            d += ` A ${radius} ${radius} 0 ${largeArc} ${sweep} ${endX} ${endY}`;
            x = endX;
            y = endY;
            heading += delta;
            points.push({ x, y });
          }
        }

        if (points.length < 2) {
          trackStatus.textContent = "Track data is empty.";
          return;
        }

        //helpful for bounding box to center and scale SVG
        let minX = points[0].x;
        let maxX = points[0].x;
        let minY = points[0].y;
        let maxY = points[0].y;
        for (const pt of points) {
          minX = Math.min(minX, pt.x);
          maxX = Math.max(maxX, pt.x);
          minY = Math.min(minY, pt.y);
          maxY = Math.max(maxY, pt.y);
        }
        
        //turning bounded box to SVG viewbox for box to fit nicely in frame
        const padding = 40;
        const width = Math.max(1, maxX - minX);
        const height = Math.max(1, maxY - minY);
        const viewBox = [
          minX - padding,
          minY - padding,
          width + padding * 2,
          height + padding * 2,
        ].join(" ");

        trackPath.setAttribute("d", d);
        if (trackSvg) {
          trackSvg.setAttribute("viewBox", viewBox);
        }
        trackStatus.textContent = `Segments: ${segments.length}`;
      }

      async function loadTrack() {
        try {
          const response = await fetch("http://localhost:8080/track");
          const data = await response.json();
          if (!response.ok || !Array.isArray(data.segments)) {
            trackStatus.textContent = "Failed to load track data.";
            return;
          }
          renderTrack(data.segments);
        } catch (error) {
          trackStatus.textContent = "Unable to reach backend for track data.";
        }
      }

      //when form is submitted, run
      //async bc a network request is made so everything else stays functional
      //async marks function as pause capable because of await
      form.addEventListener("submit", async (event) => {
        event.preventDefault(); //Don’t do the browser’s default form behavior.
        status.textContent = "Calculating...";

        const payload = {};
        //add to payload
        for (const field of fields) {
          const input = form.elements[field];
          const value = toNumber(input.value);
          if (value === null) {
            status.textContent = `Invalid value for ${field}.`;
            return;
          }
          payload[field] = value;
        }

        try {
          //send POST request with JSON data and wait for server response and then store the response
          //fetch starts network request
          //await pauses this function
          const response = await fetch("http://localhost:8080/distance", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          
          //without await, data is promise (data unavailable but will arrive in the future)
          const data = await response.json();
          if (!response.ok || !data.ok) {
            status.textContent = data.message || "Request failed.";
            return;
          }

          result.innerHTML = `Distance: <strong>${data.distanceM.toFixed(2)}</strong> m`;
          status.textContent = "Success.";
        } catch (error) {
          status.textContent = "Network error. Is the server running?";
        }
      });

      loadTrack();
    </script>
  </body>
</html>
